import arcpy, os.path, random, math
from numpy import genfromtxt

path = r"C:\PythonWorkspace\PDProject"
arcpy.env.workspace = path

# Map variables
bufferSize = "300 Meters" # The size of the buffer around the initial burglary
threshold = 80 # The threshold value for a burglar to move out of a cluster
iterations = 10 # The number of clusters to be created
backgroundBurglaries = 100 # The number of background burglaries to be created
minBurglaries = 3 # The minimum number of burglaries in a cluster
maxBurglaries = 12 # The maximum number of burglaries in a cluster

# Monte Carlo variables
maxNum = 0
minNum = 0
interval = 0
numberOfBins = 20
bins = [[0.0 for x in range(numberOfBins)] for y in range(2)]

# Previous location of initial burglary
prevPoint = (0,0)


# The following classes for performing Monte Carlo sampling are adapted from the work of Sim Reaney and Andy Evans at
# http://www.geog.leeds.ac.uk/courses/other/programming/info/code/modelling/calibration/MonteCarlo.java
# Set the frequency distribution of numbers returned by the sampler
def setNumbers(filename):
    data = fileAsArray(filename)
    
    i = 0
    while (i < numberOfBins):
        bins[0][i] = interval + (interval * (i) + minNum)

        j = 0
        while (j < len(data)):
            if data[j] < bins[0][i]:
                bins[1][i] = bins[1][i] + 1
                
            j = j + 1
            
        bins[1][i] = bins[1][i] / len(data)
        i = i + 1

# Returns a number at a rate determined by a preset distribution
def getNumber(random):
    value = 0.0
    i = 0
    
    while (i < numberOfBins):
        if random < bins[1][i]:
            value = bins[0][i]
            break
        
        i = i + 1

    return value

# Returns a file as a one-dimensional array
def fileAsArray(filename):
    data2d = genfromtxt(filename, delimiter=',')
    
    position = 0
    data = []
    global minNum
    global maxNum
    
    for line in data2d:
        for value in line:
            data.append(value)
            if position == 0:
                maxNum = value
                minNum = value
                
            if value > maxNum:
                maxNum = value
                
            if value < minNum:
                minNum = value
                
            position = position + 1

    global interval
    interval = float(maxNum - minNum)/numberOfBins

    return data



# Function to be called when creating a new model
# Creates required initial shape files and empties them if they already exist
def setup():    
    # Creates the feature class for the boundary
    if arcpy.Exists("boundary.shp"):
        print "Boundary file exists"
    else:
        arcpy.CreateFeatureclass_management(path, "boundary.shp", "POLYGON")

        # Create polygon of size 10km x 10km
        array = arcpy.Array([arcpy.Point(0, 0),
                             arcpy.Point(0, 10000),
                             arcpy.Point(10000, 10000),
                             arcpy.Point(10000, 0)
                             ])
        polygon = arcpy.Polygon(array)

        # Open an InsertCursor and insert polygon
        cursor = arcpy.da.InsertCursor("boundary.shp", ["SHAPE@"])
        cursor.insertRow([polygon])
        del cursor
        print "Boundary file created"

    # Creates the feature class for the burglaries
    if arcpy.Exists("burglaries.shp"):
        arcpy.DeleteFeatures_management("burglaries.shp")
        print "Burglaries file exists"
    else:
        arcpy.CreateFeatureclass_management(path, "burglaries.shp", "POINT")
        arcpy.AddField_management("burglaries.shp", "ITER", "SHORT")
        arcpy.AddField_management("burglaries.shp", "TYPE", "TEXT")
        print "Burglaries file created"

    # Creates the feature class for the buffers
    if arcpy.Exists("buffers.shp"):
        arcpy.DeleteFeatures_management("buffers.shp")
        print "Buffers file exists"
    else:
        arcpy.CreateFeatureclass_management(path, "buffers.shp", "POLYGON")
        arcpy.AddField_management("buffers.shp", "ITER", "SHORT")
        print "Buffers file created"

    # Creates the frequency distribution for the Monte Carlo sampling
    setNumbers(path + r'\testData.txt')
        

# Function to add random points within a boundary and append to the burglaries shape file
# Note the interim file must be separately deleted before it can be reused
def randomPoints(interimName, boundary, numPoints, iterVal, pointType):

    global prevPoint
    
    # Creates the random points
    arcpy.CreateRandomPoints_management(path, interimName, boundary, "", numPoints)
    arcpy.AddField_management(interimName, "ITER", "SHORT")
    arcpy.AddField_management(interimName, "TYPE", "TEXT")

    # Updates the fields in the table
    with arcpy.da.UpdateCursor(interimName, ["ITER", "TYPE", "SHAPE@XY"]) as cursor:
        for row in cursor:
            row[0] = iterVal
            row[1] = pointType
            if pointType == "INITIAL":
                prevPoint = (row[2][0], row[2][1])
            cursor.updateRow(row)

    # Adds the subsequent points into the burglaries.shp class that will contain all burglaries        
    arcpy.Append_management(interimName, "burglaries.shp", "NO_TEST")

# Function to add a specific point at a distance from the previous initil burglary point to the burglaries shape file
# Note the interim file must be separately deleted before it can be reused
def specificPoint(distance, bearing, interimName, boundary, iterVal):

    global prevPoint

    # Generate a random bearing from the previous point
    angle = 90 - bearing
    bearing = math.radians(bearing)
    angle =   math.radians(angle)

    # Use trigonometry to calculate new point location
    cosa = math.cos(angle)
    cosb = math.cos(bearing)
    xNew, yNew = \
        (prevPoint[0] +(distance * cosa), prevPoint[1]+(distance * cosb))
    point = arcpy.Point(xNew, yNew)

    # Search in boundary file
    cursor = arcpy.SearchCursor(boundary)
    for rowid in cursor:
        # Get boundary polygon
        polygon = rowid.Shape

        #If new point is inside boundary
        if polygon.contains(point):
            # Create the row to be added to the initPoint shapefile
            row = ((xNew, yNew), iterVal, "INITIAL")

            # Creates the feature class
            arcpy.CreateFeatureclass_management(path, interimName, "POINT")
            arcpy.AddField_management(interimName, "ITER", "SHORT")
            arcpy.AddField_management(interimName, "TYPE", "TEXT")

            # Uses an update cursor to add to the interim file
            cursor = arcpy.da.InsertCursor(interimName, ["SHAPE@XY", "ITER", "TYPE"])
            cursor.insertRow(row)
            del cursor

            # Adds the subsequent point into the burglaries.shp class that will contain all burglaries        
            arcpy.Append_management(interimName, "burglaries.shp", "NO_TEST")

            # Updates the prebvious point location
            prevPoint = (xNew, yNew)
        else:
            # Try again using the same function parameters but a new random bearing value
            specificPoint(distance, random.randint(0, 360), interimName, boundary, iterVal)


# Funtion to add a new burglary cluster within the boundary    
def newZone(distance):
    if distance == 0:
        # Creates the first random burglary point
        randomPoints("initPoint.shp", "boundary.shp", 1, iteration, "INITIAL")
    else:
        # Creates subsequent burglary point at specific position
        specificPoint(distance, random.randint(0, 360), "initPoint.shp", "boundary.shp", iteration)
    
    # Creates the buffer around the initial point
    arcpy.Buffer_analysis("initPoint.shp", "initBuff.shp", bufferSize)

    # Adds the buffer into the buffers.shp class that will contain all buffers
    arcpy.Append_management("initBuff.shp", "buffers.shp", "NO_TEST")
    
    # Delete the initial point so the class can be reused
    arcpy.Delete_management("initPoint.shp")

    # Calculate number of further burglaries
    # Bounds for number of burglaries set from parameters. 1 is subtracted to compensate for the original burglary point
    subsequent = (minBurglaries - 1)
    while random.randint(0, 100) < threshold and subsequent < (maxBurglaries - 1):
        subsequent += 1

    print "Iteration " + str(iteration) + " has " + str(subsequent + 1) + " burglaries."

    if subsequent != 0:
        # Generate further burglaries in area
        randomPoints("subsPoint.shp", "initBuff.shp", subsequent, iteration, "SECONDARY")
        
        # Delete the subsequent points so the class can be reused
        arcpy.Delete_management("subsPoint.shp")

    # Delete the initial buffer so the class can be reused
    arcpy.Delete_management("initBuff.shp")

# Function to generate random burglaries inside the boundary not related to a cluster
def randomNoise():
    # Creates the background burglaries (i.e. random noise)
    randomPoints("randomNoise.shp", "boundary.shp", backgroundBurglaries, 0, "BACKGROUND")

    # Delete the random noise points so the class can be reused
    arcpy.Delete_management("randomNoise.shp")



# Main part of the program
setup()

iteration = 1
newZone(0)
iteration += 1

while iteration <= iterations:
    newZone(getNumber(random.uniform(0,1)))
    iteration += 1

randomNoise()
